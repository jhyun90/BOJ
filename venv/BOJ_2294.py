import sys

n, k = list(map(int, sys.stdin.readline().split()))

coins = [int(sys.stdin.readline()) for _ in range(n)]

table = [0 for i in range(k + 1)]

# Base case (If given value k is 0)
table[0] = 0
print("table1", table)

# Initialize all table values as Infinite
for i in range(1, k + 1):
    table[i] = sys.maxsize

print("table2", table)

# Compute minimum coins required for all values from 1 to k
for i in range(1, k + 1):
    # Go through all coins smaller than i
    for j in range(n):
        if coins[j] <= i:
            sub_res = table[i - coins[j]]
            print("sub_res", sub_res, "table[", i - coins[j], "]", "동전의 합:", i, "동전의 가치:", coins[j])

            if sub_res != sys.maxsize and sub_res + 1 < table[i]:
                table[i] = sub_res + 1
                print("table3", table)

    print()

# 첫째 줄에 사용한 동전의 최소 개수를 출력한다. 불가능한 경우에는 -1을 출력한다.
print(table[k] if table[k] != sys.maxsize else -1)

'''
3 10
1
2
5

3 15
1
5   
12

4 11
9
6
5
1

반례
1 1
2
출력
-1
'''

# for i in range(len(coin)):
#     print("value", coin[:i + 1])
#     for j in range(coin[i], k + 1):
#         print("dp[{}] {} (개수: {}) + dp[{}] {} (개수: {}) =".format(j, dp[j], [x for x in range(j, 0, -1)[:dp[j]]], j - coin[i], dp[j - coin[i]], j // coin[i]), end=' ')
#
#         dp[j] += dp[j - coin[i]]
#
#         print("dp[{}] {} (개수: )".format(j, dp[j]))
#
#     print()

# for i in range(len(coin)):
#     print("value", coin[:i + 1])
#     # for j in range(coin[i], k + 1):
#     for j in range(0, k + 1):
#         if coin[i] == 1:
#             print(coin[i], "*", j)
#             continue
#
#         # quotient = [q for q in range(1, (j // coin[i]) + 1)]
#
#         for q in range(0, j // coin[i] + 1):
#             print(coin[i - 1], "*", (j - coin[i] * q) // coin[i - 1], "+", coin[i], "*", q, end='   ')
#
#         print()
#
#     print()



'''
(1)                             (2)                     (3)
0   (0)     (0)     1 * 0       0   (0)     2 * 0       0   (0)     3 * 0
1   (1)     (1)     1 * 1       1   (0)     2 * 0       1   (0)     3 * 0
2   (1)     (2)     1 * 2       2   (1)     2 * 1       2   (0)     3 * 0 
3   (1)     (3)     1 * 3       3   (0)     2 * 0       3   (1)     3 * 1
4   (1)     (4)     1 * 4       4   (1)     2 * 2       4   (0)     3 * 0
5   (1)     (5)     1 * 5       5   (0)     2 * 0       5   (0)     3 * 0
6   (1)     (6)     1 * 6       6   (1)     2 * 3       6   (1)     3 * 2
7   (1)     (7)     1 * 7       7   (0)     2 * 0       7   (0)     3 * 0
8   (1)     (8)     1 * 8       8   (1)     2 * 4       8   (0)     3 * 0
9   (1)     (9)     1 * 9       9   (0)     2 * 0       9   (1)     3 * 3
10  (1)     (10)    1 * 10      10  (1)     2 * 5       10  (0)     3 * 0

(1, 2)
0   (1)     (0)                             1 * 0 + 2 * 0
1   (1)     (1)                             1 * 1 + 2 * 0
2   (2)     (2) + 1                         1 * 2 + 2 * 0   1 * 0 + 2 * 1
3   (2)     (3) + 2                         1 * 3 + 2 * 0   1 * 1 + 2 * 1
4   (3)     (4) + 3 + 2                     1 * 4 + 2 * 0   1 * 2 + 2 * 1   1 * 0 + 2 * 2
5   (3)     (5) + 4 + 3                     1 * 5 + 2 * 0   1 * 3 + 2 * 1   1 * 1 + 2 * 2
6   (4)     (6) + 5 + 4 + 3                 1 * 6 + 2 * 0   1 * 4 + 2 * 1   1 * 2 + 2 * 2   1 * 0 + 2 * 3
7   (4)     (7) + 6 + 5 + 4                 1 * 7 + 2 * 0   1 * 5 + 2 * 1   1 * 3 + 2 * 2   1 * 1 + 2 * 3
8   (5)     (8) + 7 + 6 + 5 + 4             1 * 8 + 2 * 0   1 * 6 + 2 * 1   1 * 4 + 2 * 2   1 * 2 + 2 * 3   1 * 0 + 2 * 4
9   (5)     (9) + 8 + 7 + 6 + 5             1 * 9 + 2 * 0   1 * 7 + 2 * 1   1 * 5 + 2 * 2   1 * 3 + 2 * 3   1 * 1 + 2 * 4
10  (6)     (10) + 9 + 8 + 7 + 6 + 5        1 * 10 + 2 * 0  1 * 8 + 2 * 1   1 * 6 + 2 * 2   1 * 4 + 2 * 3   1 * 2 + 2 * 4   1 * 0 + 2 * 5

(1, 2, 5)
1   (1)     (1)                             (1 * 1 + 2 * 0) + 5 * 0
2   (2)     (2 + 1)                         (1 * 2 + 2 * 0) + 5 * 0   (1 * 0 + 2 * 1) + 5 * 0
3   (2)     (3 + 2)                         (1 * 3 + 2 * 0) + 5 * 0   (1 * 1 + 2 * 1) + 5 * 0
4   (3)     (4 + 3 + 2)                     (1 * 4 + 2 * 0) + 5 * 0   (1 * 2 + 2 * 1) + 5 * 0   (1 * 0 + 2 * 2) + 5 * 0
5   (4)     (5 + 4 + 3) + 1                 (1 * 5 + 2 * 0) + 5 * 0   (1 * 3 + 2 * 1) + 5 * 0   (1 * 1 + 2 * 2) + 5 * 0   (1 * 0 + 2 * 0) + 5 * 1
6   (5)     (6 + 5 + 4 + 3) + 2             (1 * 6 + 2 * 0) + 5 * 0   (1 * 4 + 2 * 1) + 5 * 0   (1 * 2 + 2 * 2) + 5 * 0   (1 * 0 + 2 * 3) + 5 * 0   (1 * 1 + 2 * 0) + 5 * 1
7   (6)     (7 + 6 + 5 + 4) + 3 + 2         (1 * 7 + 2 * 0) + 5 * 0   (1 * 5 + 2 * 1) + 5 * 0   (1 * 3 + 2 * 2) + 5 * 0   (1 * 1 + 2 * 3) + 5 * 0   (1 * 2 + 2 * 0) + 5 * 1   (1 * 0 + 2 * 1) + 5 * 1
8   (7)     (8 + 7 + 6 + 5 + 4) + 4 + 3     (1 * 8 + 2 * 0) + 5 * 0   (1 * 6 + 2 * 1) + 5 * 0   (1 * 4 + 2 * 2) + 5 * 0   (1 * 2 + 2 * 3) + 5 * 0   (1 * 0 + 2 * 4) + 5 * 0   (1 * 3 + 2 * 0) + 5 * 1   (1 * 1 + 2 * 1) + 5 * 1
9   (8)     (9 + 8 + 7 + 6 + 5) + 5 + 4 + 3 (1 * 9 + 2 * 0) + 5 * 0   (1 * 7 + 2 * 1) + 5 * 0   (1 * 5 + 2 * 2) + 5 * 0   (1 * 3 + 2 * 3) + 5 * 0   (1 * 1 * 2 * 4) + 5 * 0   (1 * 4 + 2 * 0) + 5 * 1   (1 * 2 + 2 * 1) + 5 * 1   (1 * 0 + 2 * 2) + 5 * 1
10  (10)    (10 + 9 + 8 + 7 + 6 + 5) + 6 + 5 + 4 + 2 (1 * 10 + 2 * 0) + 5 * 0  (1 * 8 + 2 * 1) + 5 * 0   (1 * 6 + 2 * 2) + 5 * 0   (1 * 4 + 2 * 3) + 5 * 0   (1 * 2 * 2 * 4) + 5 * 0   (1 * 0 + 2 * 5) + 5 * 0   (1 * 5 + 2 * 0) + 5 * 1   (1 * 3 + 2 * 1) + 5 * 1   (1 * 1 + 2 * 2) + 5 * 1   (1 * 0 + 2 * 0) + 5 * 2

[구현 방법]
(1, 2) -> 2의 배수를 간격으로 증가 고려
1   (1)     1(-> 1을 사용하여 합이 1이 되는 경우의 수: 1) + 2 * 0
2   (2)     2(-> 1을 사용하여 합이 2가 되는 경우의 수: 1) + 2 * 0        0(-> 1을 사용하여 합이 0이 되는 경우의 수: 1) + 2 * 1
3   (2)     3(-> 1을 사용하여 합이 3이 되는 경우의 수: 1) + 2 * 0        1(-> 1을 사용하여 합이 1이 되는 경우의 수: 1) + 2 * 1
4   (3)     4(-> 1을 사용하여 합이 4가 되는 경우의 수: 1) + 2 * 0        2(-> 1을 사용하여 합이 2가 되는 경우의 수: 1) + 2 * 1      0(-> 1을 사용하여 합이 0이 되는 경우의 수: 1) + 2 * 2
...
dp[2] 1 (2) + dp[0]+1 1 (0 + 1) = dp[2] 2 (3)
dp[3] 1 (3) + dp[1]+1 1 (1 + 1) = dp[3] 2 (5)
dp[4] 1 (4) + dp[2]+1 2 (3 + 2 / 3 + 2) = dp[4] (9)
dp[5] 1 (5) + dp[3]+1 2 (4 + 3 / 5 + 2) = dp[5] 3 (12)
dp[6] 1 (6) + dp[4]+1 3 (5 + 4 + 3 / 9 + 3) = dp[6] 4 (18)
dp[7] 1 (7) + dp[5]+1 3 (6 + 5 + 4 / 12 + 3) = dp[7] 4 (22)
dp[8] 1 (8) + dp[6]+1 4 (7 + 6 + 5 + 4) = dp[8] 5
dp[9] 1 (9) + dp[7]+1 4 (8 + 7 + 6 + 5) = dp[9] 5
dp[10] 1 + dp[8] 5 = dp[10] 6

(1, 2, 5) -> 5의 배수를 간격으로 증가 고려
1   (1)     1(-> 1과 2를 사용하여 합이 1이 되는 경우의 수: 1) + 5 * 0
2   (2)     2(-> 1과 2를 사용하여 합이 2가 되는 경우의 수: 2) + 5 * 0
...
5   (4)     5(-> 1과 2를 사용하여 합이 5가 되는 경우의 수: 3) + 5 * 0     0(-> 1과 2를 사용하여 합이 0이 되는 경우의 수: 1) + 5 * 1
6   (5)     6(-> 1과 2를 사용하여 합이 6이 되는 경우의 수: 4) + 5 * 0     1(-> 1과 2를 사용하여 합이 1이 되는 경우의 수: 1) + 5 * 1
7   (6)     7(-> 1과 2를 사용하여 합이 7이 되는 경우의 수: 4) + 5 * 0     2(-> 1과 2를 사용하여 합이 2가 되는 경우의 수: 2) + 5 * 1
...
10  (10)    10(-> 1과 2를 사용하여 합이 10이 되는 경우의 수: 6) + 5 * 0   5(-> 1과 2를 사용하여 합이 5가 되는 경우의 수: 3) + 5 * 1   0(1과 2를 사용하여 합이 0이 되는 경우의 수: 1) + 5 * 2
'''
